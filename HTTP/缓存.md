# 缓存

HTTP的缓存分为：强制缓存 + 协商缓存

## 缓存过程分析

1. 浏览器发起HTTP请求，随后，服务器响应该请求返回资源，浏览器第一次拿到结果后，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果。

2. 如果存在强缓存响应头，第二次请求的时候就走强缓存，如果强缓存过期，就走协商缓存

3. 协商缓存请求服务器，资源是否过期，如果没有过期，返回304，请求缓存资源

4. 如果过期，返回新资源，状态码200

## 强制缓存

强制缓存主要通过http请求头中的 **`Cache-Control`(http/1.1) 和 `Expires`(http/1)** 两个字段来控制。其中，`Cache-control` 优先级更高。

`Cache-Control` 的值为 `public, max-age=xxx`，表示在xxx秒内再次访问该资源，均适用本地的缓存，不再向服务器发起请求。

### Cache-Control

- public 所有内容都将被缓存（客户端和代理服务器都可以缓存）
- private 默认值，所有内容只有客户端可以缓存
- no-cache 客户端缓存内容，但是是否缓存需要经过协商缓存来验证决定
- no-store 既不协商缓存，也不使用强缓存
- max-age=xxx 缓存内容在xxx秒后失效

### 强制缓存的缺点

如果在xxx秒内，服务器上面的资源更新了，客户端在没有强制刷新的情况下，内容还是旧的，但是，如果后台接口也同步更新了，就会出错了。

## 协商缓存

协商缓存在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存。

控制协商缓存的响应头是：`Last-Modified / If-Modified-Since / Etag(优先级高) / If-None-Match(优先级高)`

### 协商缓存的缺点

每次请求都需要向服务器验证一下缓存的有效性。

## 区别

区别在于：使用本地缓存的时候，是否需要向服务器验证本地缓存是否有效。

协商缓存：需要和服务器进行协商，最终确定是否使用本地缓存。

## 最佳实践

缓存的意义在于减少请求，更多地使用本地缓存，最佳实践，应该是尽可能命中强缓存，同时，在更新版本的时候让客户端的缓存失效。

为了达到此目的，**可以在更新版本的时候，顺便把静态资源的路径修改了，这样，就相当于第一次访问这些资源，不会存在缓存的问题。**

在webpack打包的时候，在文件的命名上带上hash值。

合理的缓存解决方案：

- HTML：使用协商缓存
- CSS & JS & 图片：使用强缓存，文件命名带上hash值

## 三种刷新操作对缓存的影响

- 正常操作：输入url、跳转链接、前进后退等
- 手动刷新：f5、刷新按钮、右键菜单刷新
- 强制刷新：ctrl+f5、shift+cmd+r

正常操作：强制缓存有效、协商缓存有效
手动刷新：强制缓存失效，协商缓存有效
强制刷新：均无效

## 总结

强缓存优先于协商缓存，强缓存生效则直接使用强缓存，若不生效则使用协商缓存，协商缓存由服务器控制缓存是否生效，如果生效，返回304，如果不生效，返回新资源，状态码200。
